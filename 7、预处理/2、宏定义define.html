<html>
<head>
  <title>2、宏定义#define</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601967 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="5156"/>
<h1>2、宏定义#define</h1>

<div>
<span><div><div><div><h1><span style="font-size: 36pt;">宏 #define</span></h1><div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">宏</span></div><ul><li><div>作用域从它在文件中的声明处开始，直到用#undef指令取消宏为止，或延伸至文件尾；</div></li><li><div>当预处理器在程序中找到标识符时，就会用替换列表代替该宏【宏展开】，如果替换列表中还包含宏，则继续替换【除了双引号中的宏】；</div></li><li><div>宏不可以被定义两遍，除非新的定义与旧的定义是一样的；</div></li><li><div>一般不要在宏中使用递增或递减运算符；</div></li><li><div>如果宏通过头文件引入，那么#define在文件中的位置取决于#include指令的位置；</div></li><li><div>宏的作用域是从宏定义命令起到源程序结束；</div></li><li><div>宏名在源程序中如果用双引号括起来，则预处理程序不对其进行宏替换。</div></li></ul><div><br/></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 14pt; font-weight: bold;">宏的一般使用</span></div><ul><li><div>对类型名进行重命名；</div></li><li><div>控制条件编译；</div></li><li><div>定义常量；</div></li><li><div>定义无类型的函数。</div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">1、类对象宏</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define 标识符 替换列表</div></div><ul><li><div>不要在宏定义中放任何额外的符号，否则它们会被当做替换列表的一部分。</div></li><li><div>替换列表过长时，可以使用反斜杠\表示换行。</div></li><li><div>标识符应该使用大写。</div></li><li><div>适当使用圆括号表达替换体。</div></li></ul><div><br/></div><div><br/></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt; font-weight: bold;">2、类函数宏</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define 类函数宏(x1,x2,...,xn)  替换函数体</div></div><ul><li><div>必要时要使用足够多的圆括号来确保运算和结合的正确顺序。</div></li><li><div>在宏定义中的参数为形参，在宏调用中的参数为实参。</div></li><li><div>允许宏调用中的任意或所有参数为空。</div></li></ul><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">优点</span></div><ul><li><div>带参数宏没有函数的运行开销（存储上下文信息、复制参数的值），程序执行时会更快。</div></li><li><div>宏的参数没有类型，只要预处理后的程序依然是合法的，宏就可以接受任何类型的参数。</div></li></ul><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">缺点</span></div><ul><li><div>导致程序的源代码增加。</div></li><li><div>宏参数没有类型检查，也不会进行类型转换。</div></li><li><div>无法用一个指针来指向一个宏。</div></li><li><div>宏可能会不止一次地计算它的参数。</div></li></ul><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">操作符</span></div><div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 49px;"></col><col style="width: 112px;"></col><col style="width: 257px;"></col></colgroup><tbody><tr><td style="width: 49px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-weight: bold; font-size: 9pt;">序号</span></div></td><td style="width: 112px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-weight: bold; font-size: 9pt;">操作符</span></div></td><td style="width: 257px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-weight: bold; font-size: 9pt;">作用</span></div></td></tr><tr><td style="width: 49px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-size: 9pt;">1</span></div></td><td style="width: 112px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-size: 9pt;">#</span></div></td><td style="width: 257px; padding: 8px; border: 1px solid;"><div><span style="font-size: 9pt;">将宏的实参转换为字符串。</span></div></td></tr><tr><td style="width: 49px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-size: 9pt;">2</span></div></td><td style="width: 112px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-size: 9pt;">##</span></div></td><td style="width: 257px; padding: 8px; border: 1px solid;"><div><span style="font-size: 9pt;">将宏的实参替换为替换函数体的一部分。</span></div></td></tr><tr><td style="width: 49px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-size: 9pt;">3</span></div></td><td style="width: 112px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-size: 9pt;">...</span></div></td><td style="width: 257px; padding: 8px; border: 1px solid;"><div><span style="font-size: 9pt;">不定长形参，置于参数列表的末端。</span></div></td></tr><tr><td style="width: 49px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-size: 9pt;">4</span></div></td><td style="width: 112px; padding: 8px; border: 1px solid;"><div style="text-align: center;"><span style="font-size: 9pt;">__VA_ARGS__</span></div></td><td style="width: 257px; padding: 8px; border: 1px solid;"><div><span style="font-size: 9pt;">在替换函数体中对应三点号...。</span></div></td></tr></tbody></table><div><br/></div></div><div><span style="font-weight: bold;">1、#符号——将实参名转换为字符串输出</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define PX(i) printf(&quot;The square of &quot; <b>#i </b>&quot; is %d.\n&quot;,i)</div><div><br/></div><div>int main(){</div><div><br/></div><div>    int y = 5;</div><div><br/></div><div>    PX(y);                 <b>// 等于 printf(&quot;The square of y is %d.\n&quot;,y);</b></div><div><br/></div><div>    PX(2+4);               <b>// 等于 printf(&quot;The square of 2+4 is %d.\n&quot;,6);</b></div><div><br/></div><div>    return 0;</div><div>}</div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">2、##符号——将实参名转换为标识符的一部分</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define XNAME(n) <b>x##n</b></div><div>#define PRINT_XN(n) printf(&quot;x&quot; <b>#n</b> &quot; = %d\n&quot;, <b>x##n</b> )</div><div><br/></div><div>int main(void){</div><div><br/></div><div>    char XNAME(1) = 'a';    <b>// 变成 char x1 = 'a'</b></div><div><br/></div><div>    int x2 = 30;</div><div><br/></div><div>    PRINT_XN(1);            <b>// 等于 printf(&quot;x1 = %c\n&quot;,x1)</b></div><div>    PRINT_XN(2);            <b>// 等于 printf(&quot;x2 = %d\n&quot;,x2)</b></div><div><br/></div><div>    return 0;</div><div>}</div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">3、变参宏 ... 和 __VA_ARGS__</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#define PR(<b>...</b>) printf(<b>__VA_ARGS__</b>)  </div><div>#define PRR(X,<b>...</b>) printf(&quot;Message &quot; <b>#X</b> &quot;:&quot; <b>__VA_ARGS__</b>)</div><div><br/></div><div>int main(void){</div><div><br/></div><div>    int x = 10;</div><div>    int y = 20;</div><div><br/></div><div>    PR(&quot;Howdy&quot;);                   <b>// 等于 printf(&quot;Howdy&quot;)</b></div><div>    PRR(1,&quot;x=%d\n&quot;,x);             <b>// 等于 printf(&quot;Message 1:x=%d\n&quot;,x)</b></div><div>    PRR(2,&quot;x=%d,y=%d\n&quot;,x,y);      <b>// 等于 printf(&quot;Message 2:x=%d,y=%d\n&quot;,x,y)</b></div><div><br/></div><div>    return 0;</div><div>}</div></div><div><br/></div></div><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">3、宏取消</span></div><div>取消已定义的#define指令【即使没有定义】</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#undef 标识符</div></div><ul><li><div>如果标识符不是宏，则对于预处理器是未定义的；</div></li><li><div>如果标识符是同一个文件中由前面的#define指令创建的宏名，而且没有用其他#undef指令关闭，那么该标识符是已定义的。</div></li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">const与#define的差异</span></div><ul><li><div>编译器处理方式不同。define宏在预处理阶段展开；const常量在编译运行阶段使用。</div></li><li><div>类型和安全检查不同。define宏没有类型，不做任何类型检查，仅仅是展开；const常量有具体的类型，在编译阶段会执行类型检查。</div></li><li><div>存储方式不同。define宏仅仅展开，有多少地方使用就展开多少次，不会分配内存；congst常量会在内存中分配。</div></li><li><div>使用const可以节省空间，避免不必要的内存分配。效率更高。</div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 